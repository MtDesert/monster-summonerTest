{
  "version": 3,
  "sources": [
    "unknown"
  ],
  "names": [],
  "mappings": "AAAA,IAAI,OAAO,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC;;;AAGjC,EAAE,CAAC,KAAK,CAAC;AACL,eAAS,EAAE,CAAC,SAAS;;AAErB,YAAQ,EAAE,oBAAY;;;AAElB,YAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;;AAE9C,YAAI,CAAC,iBAAiB,GAAG,IAAI,EAAE,CAAC,QAAQ,EAAE,CAAC;;AAE3C,YAAI,CAAC,WAAW,GAAG,CAAC,CAAC;;;AAKrB,YAAI,CAAC,qBAAqB,EAAE,CAAC;KAEhC;;AAED,yBAAqB,EAAE,iCAAU;AAC7B,YAAI,sBAAsB,GAAG,EAAE,CAAC;AAChC,aAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,sBAAsB,EAAE,EAAE,CAAC,EAAE;AAC7C,gBAAI,aAAa,GAAG,EAAE,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;AAC/D,gBAAI,CAAC,iBAAiB,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;SAC7C;KACJ;;AAED,8BAA0B,EAAE,oCAAU,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE;AAClE,YAAI,aAAa,GAAG,IAAI,CAAC;AACzB,YAAI,IAAI,CAAC,iBAAiB,CAAC,IAAI,EAAE,GAAG,CAAC,EAAE;;AACnC,yBAAa,GAAG,IAAI,CAAC,iBAAiB,CAAC,GAAG,EAAE,CAAC;SAChD,MAAM;;AACH,yBAAa,GAAG,EAAE,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC;SAC9D;AACD,qBAAa,CAAC,MAAM,GAAG,UAAU,CAAC;AAClC,qBAAa,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;;;AAGpC,qBAAa,CAAC,YAAY,CAAC,mBAAmB,CAAC,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC;AACzE,qBAAa,CAAC,YAAY,CAAC,mBAAmB,CAAC,CAAC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC;AAC7E,qBAAa,CAAC,YAAY,CAAC,mBAAmB,CAAC,CAAC,SAAS,GAAG,QAAQ,CAAC,SAAS,CAAC;AAC/E,qBAAa,CAAC,YAAY,CAAC,mBAAmB,CAAC,CAAC,OAAO,GAAG,QAAQ,CAAC,OAAO,CAAC;;;AAG3E,qBAAa,CAAC,SAAS,CAAC,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,EAC5B,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;KAE9F;;AAED,UAAM,EAAE,gBAAU,EAAE,EAAE;;AAElB,YAAI,CAAC,WAAW,IAAI,EAAE,CAAC;AACvB,YAAG,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAC;;AAEhD,gBAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;AACrF,gBAAI,CAAC,WAAW,GAAG,CAAC,CAAC;SACxB;KACJ;CACJ,CAAC,CAAC",
  "file": "unknown",
  "sourcesContent": [
    "var allData = require('allData');//引用所有公共数据\r\n//控制hero攻击的脚本\r\n\r\ncc.Class({\r\n    extends: cc.Component,\r\n\r\n    onEnable: function () {//统一用onEnable初始化，重新激活时此函数也会调用\r\n        //所有hero节点下的脚本都引用 heroData 数据\r\n        this.heroData = this.getComponent('heroData'); \r\n        //创建一个heroBallistic的节点池 this.heroBallisticPool\r\n        this.heroBallisticPool = new cc.NodePool();\r\n        //hero攻击计时器初始化\r\n        this.attackTimer = 0;\r\n\r\n\r\n\r\n        //初始化this.heroBallisticPool\r\n        this.heroBallisticPoolInit();\r\n\r\n    },\r\n\r\n    heroBallisticPoolInit: function(){\r\n        var heroBallisticInitCount = 10;//默认最多10粒子弹在场\r\n        for (var i = 0; i < heroBallisticInitCount; ++i) {\r\n            var heroBallistic = cc.instantiate(this.heroData.bulletPrefab); //生成子弹\r\n            this.heroBallisticPool.put(heroBallistic); // 通过 put 接口放入对象池\r\n        }\r\n    },\r\n\r\n    createHeroBallistic_Attack: function (parentNode, position, attacker) {\r\n        var heroBallistic = null;\r\n        if (this.heroBallisticPool.size() > 0) { // 通过 size 接口判断对象池中是否有空闲的对象\r\n            heroBallistic = this.heroBallisticPool.get();\r\n        } else { // 如果没有空闲对象，也就是对象池中备用对象不够时，就用 cc.instantiate 重新创建\r\n            heroBallistic = cc.instantiate(this.heroData.bulletPrefab);\r\n        }\r\n        heroBallistic.parent = parentNode; // 将生成的heroBallistic加入节点树\r\n        heroBallistic.setPosition(position);\r\n\r\n        //将玩家当前所有攻击属性赋予子弹！\r\n        heroBallistic.getComponent('heroBallisticData').damage = attacker.damage;\r\n        heroBallistic.getComponent('heroBallisticData').critProb = attacker.critProb;\r\n        heroBallistic.getComponent('heroBallisticData').critTimes = attacker.critTimes;\r\n        heroBallistic.getComponent('heroBallisticData').vampire = attacker.vampire;\r\n\r\n        //子弹飞起来，攻击！hero当前位置向上飞行一个canvas高度\r\n        heroBallistic.runAction(cc.moveTo(this.heroData.ballisticSpeed, \r\n                                          this.node.x, this.node.y + this.heroData.canvas.height));\r\n        \r\n    },\r\n\r\n    update: function (dt) {\r\n        //hero攻击的计时器，每隔一个单位攻击间隔就攻击一次\r\n        this.attackTimer += dt;\r\n        if(this.attackTimer >= this.heroData.attackInterval){\r\n            //在hero当前位置生成子弹 and 将玩家当前攻击属性赋予子弹！子弹发射！\r\n            this.createHeroBallistic_Attack(this.node.parent, this.node.position, this.heroData);\r\n            this.attackTimer = 0;\r\n        }   \r\n    },\r\n});\r\n"
  ]
}